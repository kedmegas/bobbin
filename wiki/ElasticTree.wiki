= Elastic Hash Tree =

An elastic hash tree is a binary [http://en.wikipedia.org/wiki/Hash_tree hash tree] that allows extension of the hashed data, can be efficiently queried and updated, and is compactly represented in memory.

An elastic hash tree consists of one or more *views*, each corresponding to a particular length of hashed data and containing mutable hash nodes that are only valid for that view, and a single *immutable set* of hash nodes that are valid for all views.

The nodes of an elastic hash tree are numbered by [http://en.wikipedia.org/wiki/Postorder postorder traversal]

== Implementation ==

See [http://code.google.com/p/bobbin/source/browse/#svn/trunk/Bobbin/src/org/itadaki/bobbin/util/elastictree]

== Explanation ==

Yellow nodes are the *immutable set*

Orange nodes are *mutable view nodes*

Blue nodes are *filler nodes*. A filler leaf node is defined to have a hash of all zeroes

=== Example 1 ===
A view modeling data of length 950, with a piece size of 100, has 9 immutable leaves and 1 mutable leaf

<img src="http://bobbin.googlecode.com/svn/wiki/postorder_tree_example1.png">

Leaves 0 .. 8 (node indices 0, 1, 3, 4, 7, 8, 10, 11, 15) that each represent a complete piece are valid for any view that require them. Leaf 9 (node index 16) is only valid for this view; a view of differing length will instead use a filler node (for a view of less than 10 leaves), a different mutable node (for a different view of 10 leaves), or the node from the immutable set (for a view of more than 10 leaves).

Note the following properties that are true for a view of any length :
{{{
Property : The immutable set form a contiguous list of node indices
}}}

{{{
Property : Mutable view nodes form a single path from the root
}}}
(The view path is not always the length of the full height of the tree - see the following example).

These two properties form the basis of the compact representation of the tree.

{{{
Property : Existing node indices do not change when more leaves are added, even if the height of the tree changes as a result
}}}

This property ensures that extending the tree is a time efficient operation, as the immutable set does not have to be rewritten for different length views.


=== Example 2 ===
A view modeling data of length 1000, with a piece size of 100, has 10 immutable leaves and 0 mutable leaves

<img src="http://bobbin.googlecode.com/svn/wiki/postorder_tree_example2.png">

Although there are no mutable leaves in this view, there are mutable nodes that are the ancestor of both immutable and filler nodes. When the last leaf in the view (the *view leaf*) is immutable, immutable nodes continue as far as can be moved up-left. A view of exactly 2^n^ complete leaves will therefore contain no mutable nodes.



== Tree properties ==

  * An array of n hashes is modelled as the leaves of a perfect binary tree of height `ceil(log2(n))`, containing `2^height` leaves, and `2 * leaves - 1` total nodes
  * The nodes of the tree are numbered according to their sequence in a post order traversal, with zero being the first node (the first leaf)
  * The tree is considered to grow upwards from the leaves, such that for any leaf `e`, `height(e) = 0`
  * Leaves with a leaf number greater than `n - 1` are filler leaves, considered to have a hash of zero
  * A filler node f at a given height within the tree has the following identity : `filler(0) = 0 ; filler(height(f)) = hash(filler(height(f)-1),filler(height(f)-1))`
  * The root node of the tree is always the last numbered node, with node index `2 * leaves - 2`
  * The node index of a leaf number `i` has the following identity: `nodeindex(i) = (2 * i) + ones(i)`, where `ones()` counts the number of set bits in an integer
  * A leaf with a leaf number `i` is a left sibling if `i % 1 == 0`, otherwise it is a right sibling
  * The parent of a left sibling `ls` is `ls + 2^(height(ls) + 1)`
  * The parent of a right sibling `rs` is `rs + 1`
  * The path from a leaf with a leaf index of `i` to the root node is contained within the bits of `i` starting with the smallest; at each point on the path, the node is a left sibling if the next bit is 0, otherwise it is a right sibling
  * Given a view of length `b`, with a piece size `p` and a highest non-filler leaf number `n`;
    * For a given leaf node index `x`, let `path(x)` be the set of nodes on the path between `x` and the root
    * Let `trailingOnes(x)` be the number of bits in `x`, starting at the smallest, that are set before the first `0` is reached
    * If `(b % p) > 0`, tree nodes `0 .. nodeindex(n) - 1` are immutable; tree nodes in `path(nodeindex(n))` are mutable and will change if `b` grows
    * If `(b % p) == 0`, tree nodes `0 .. (nodeindex(n) - 1 + trailingOnes(n))` are immutable and will not change even if b grows; tree nodes in `path(nodeindex(n))` that are greater than the final immutable node are mutable and will change if `b` grows