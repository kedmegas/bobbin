= The Elastic Tree =

The Elastic tree is a tree structure suitable for modeling an expandable [http://en.wikipedia.org/wiki/Hash_tree Merkle tree] in a way that is both space and time efficient

An Elastic tree is a perfect binary tree consisting of an *immutable set* of hash nodes and one or more *views* consisting of mutable hash nodes that may be replaced

Nodes in an Elastic tree are numbered by [http://en.wikipedia.org/wiki/Postorder postorder traversal]

== Explanation ==

Yellow nodes are the *immutable set*

Orange nodes are *mutable view nodes*

Blue nodes are *filler nodes*. A filler leaf node is defined to have a hash of all zeroes

=== Example 1 ===
A tree modeling 9 immutable leaves and 1 mutable leaf

<img src="http://bobbin.googlecode.com/svn/wiki/postorder_tree_example1.png">

=== Example 2 ===
A tree modeling 10 immutable leaves and 0 mutable leaves

<img src="http://bobbin.googlecode.com/svn/wiki/postorder_tree_example2.png">

Note that :
  * Existing node indices do not change when more leaves are added, even if the height of the tree changes as a result
  * The node indices of the immutable set are contiguous
  * The number of mutable nodes in a view is limited to the height of the tree


== Tree properties ==

  * An array of n hashes is modelled as the leaves of a perfect binary tree of height `ceil(log2(n))`, containing `2^height` leaves, and `2 * leaves - 1` total nodes
  * The nodes of the tree are numbered according to their sequence in a post order traversal, with zero being the first node (the first leaf)
  * The tree is considered to grow upwards from the leaves, such that for any leaf `e`, `height(e) = 0`
  * Leaves with a leaf number greater than `n - 1` are filler leaves, considered to have a hash of zero
  * A filler node f at a given height within the tree has the following identity : `filler(0) = 0 ; filler(height(f)) = hash(filler(height(f)-1),filler(height(f)-1))`
  * The root node of the tree is always the last numbered node, with node index `2 * leaves - 2`
  * The node index of a leaf number `i` has the following identity: `nodeindex(i) = (2 * i) + ones(i)`, where `ones()` counts the number of set bits in an integer
  * A leaf with a leaf number `i` is a left sibling if `i % 1 == 0`, otherwise it is a right sibling
  * The parent of a left sibling `ls` is `ls + 2^(height(ls) + 1)`
  * The parent of a right sibling `rs` is `rs + 1`
  * The path from a leaf with a leaf index of `i` to the root node is contained within the bits of `i` starting with the smallest; at each point on the path, the node is a left sibling if the next bit is 0, otherwise it is a right sibling
  * Given a tree `t` that represents a growable, append-only array of bytes with initial length `b` with a leaf hash for each `p` bytes, for a total of `n` non-filler leaves;
    * For a given leaf node index `x`, let `path(x)` be the set of nodes on the path between `x` and the root
    * The cardinality of `path(x)` is `height(root) + 1`
    * Nodes greater than `nodeindex(n - 1)` that are not in `path(nodeindex(n - 1))` are filler nodes
    * Let `q` be the highest immutable node index
      * *FIXME This definition is slightly wrong*
      * If `(b % p) == 0`, tree nodes `0 .. nodeindex(n - 1)` are immutable and will not change even if b grows
      * If `(b % p) > 0`, tree nodes `0 .. nodeindex(n - 1) - 1` are immutable; tree nodes in `path(nodeindex(n - 1))` are mutable and will change if `b` grows
    * => `t` can be modelled as a flat array of immutable nodes `0 .. q`, and, iff `q < n`, a mutable path consisting of `path(n)`